<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>queue.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Chat.html">Chat</a><ul class='methods'><li data-type='method'><a href="Chat.html#attachClient">attachClient</a></li><li data-type='method'><a href="Chat.html#newMessage">newMessage</a></li></ul></li><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#addVote">addVote</a></li><li data-type='method'><a href="Client.html#broadcast">broadcast</a></li><li data-type='method'><a href="Client.html#emit">emit</a></li><li data-type='method'><a href="Client.html#getVotes">getVotes</a></li><li data-type='method'><a href="Client.html#on">on</a></li></ul></li><li><a href="ClientManager.html">ClientManager</a><ul class='methods'><li data-type='method'><a href="ClientManager.html#emitToAll">emitToAll</a></li><li data-type='method'><a href="ClientManager.html#getClientsCount">getClientsCount</a></li></ul></li><li><a href="Logger.html">Logger</a><ul class='methods'><li data-type='method'><a href="Logger.html#.error">error</a></li><li data-type='method'><a href="Logger.html#.info">info</a></li></ul></li><li><a href="Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="Queue.html#add">add</a></li><li data-type='method'><a href="Queue.html#deleteItem">deleteItem</a></li><li data-type='method'><a href="Queue.html#getInfo">getInfo</a></li><li data-type='method'><a href="Queue.html#getItems">getItems</a></li><li data-type='method'><a href="Queue.html#run">run</a></li><li data-type='method'><a href="Queue.html#stop">stop</a></li><li data-type='method'><a href="Queue.html#triggerOnQueueChanged">triggerOnQueueChanged</a></li><li data-type='method'><a href="Queue.html#work">work</a></li></ul></li><li><a href="QueueManager.html">QueueManager</a><ul class='methods'><li data-type='method'><a href="QueueManager.html#attachClient">attachClient</a></li></ul></li><li><a href="Song.html">Song</a><ul class='methods'><li data-type='method'><a href="Song.html#getCurrentSeekPosition">getCurrentSeekPosition</a></li><li data-type='method'><a href="Song.html#getDurationInSec">getDurationInSec</a></li><li data-type='method'><a href="Song.html#getEndsInMs">getEndsInMs</a></li><li data-type='method'><a href="Song.html#getInfo">getInfo</a></li><li data-type='method'><a href="Song.html#getVideoUrlParams">getVideoUrlParams</a></li><li data-type='method'><a href="Song.html#isOver">isOver</a></li><li data-type='method'><a href="Song.html#loadRelatedVideos">loadRelatedVideos</a></li><li data-type='method'><a href="Song.html#play">play</a></li><li data-type='method'><a href="Song.html#setVotes">setVotes</a></li></ul></li><li><a href="VotesManager.html">VotesManager</a><ul class='methods'><li data-type='method'><a href="VotesManager.html#addVote">addVote</a></li><li data-type='method'><a href="VotesManager.html#attachClient">attachClient</a></li><li data-type='method'><a href="VotesManager.html#getVotesCount">getVotesCount</a></li><li data-type='method'><a href="VotesManager.html#hasVotedFor">hasVotedFor</a></li><li data-type='method'><a href="VotesManager.html#recalculateVotes">recalculateVotes</a></li></ul></li><li><a href="YoutubeApi.html">YoutubeApi</a><ul class='methods'><li data-type='method'><a href="YoutubeApi.html#getRelatedVideos">getRelatedVideos</a></li><li data-type='method'><a href="YoutubeApi.html#getVideo">getVideo</a></li><li data-type='method'><a href="YoutubeApi.html#simpleGetRequest">simpleGetRequest</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#socketIoExpressInitializer">socketIoExpressInitializer</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">queue.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const moment = require('moment');
const Song = require('./song.js');
const Logger = require('./logger.js');
const YoutubeApi = require('./youtube-api.js');
const youTubeApi = new YoutubeApi(process.env.YOUTUBE_API_KEY);

/**
 * Contains the list of songs and plays the next one at the correct time
 *
 * @type {Queue}
 */
class Queue {

	/**
	 * @param {ClientManager} clientManager For sending song and queue info to clients
	 */
	constructor(clientManager) {
		this.items = [];
		this.active = null;
		this.relatedVideoIsLoading = false;

		let queueInterval = null;

		/**
		 * When the queue changes we want to
		 * broadcast the new queue to all
		 * users so they're up-to-date
		 */
		let onQueueChanged = () => {
			// Send queue info:
			clientManager.emitToAll('queue_info', this.getInfo());
		};

		let onRelatedChanged = song => {
			// Send queue info:
			clientManager.emitToAll('related_info', song.relatedVideos);
		};

		this.emitToAll = (event, data) => {
			clientManager.emitToAll(event, data);
		};

		/**
		 * Use this to manually trigger an update to the queue/positions
		 * and display it to all users. Can be used for example when a
		 * user disconnects and we want to update visually the queue
		 */
		this.triggerOnQueueChanged = () => {
			onQueueChanged();
		};

		this.triggerOnRelatedChanged = song => {
			onRelatedChanged(song);
		};

		this.run();
	}

	/**
	 * Returns the items in the queue
	 * sorted by the priority based
	 * on the votes of the users
	 *
	 * @return {[Song]} Array of song items, sorted by votes/position
	 */
	getItems() {
		// Make a fresh copy of the original items
		let copyItems = this.items.slice();

		// sort by votes
		copyItems.sort((item1, item2) => {
			if(item1.votes > item2.votes) {
				return -1;
			}

			if(item1.votes &lt; item2.votes) {
				return 1;
			}

			return 0;
		});

		return copyItems;
	}

	/**
	 * Returns info about the queue, this includes an
	 * array of {@link Song.getInfo} for all songs,
	 * sorted by votes from {@link Queue.getItems}
	 *
	 * @returns {Array}
	 */
	getInfo() {
		let queueInfo = [];
		let queueSortedItems = this.getItems();

		for(let item of queueSortedItems) {
			// Get info for the song
			let songInfo = item.getInfo();

			queueInfo.push(songInfo);
		}

		return queueInfo;
	}

	/**
	 * Adds a new song to the queue,
	 * owned by the Client provided,
	 * video is fetched by videoId.
	 *
	 * Note: Can emit `be_alerted` event and not add the
	 * song if one of the conditions below is met:
	 * - The song is already playing
	 * - The song is already in the queue
	 * - The video is not embeddable
	 *
	 * Note: Triggers {@link this.triggerOnQueueChanged} when song is added
	 *
	 * @param {Client} client
	 * @param {String} videoId
	 */
	add(client, videoId) {
		// check if song is already playing, prevent adding
		if(this.active &amp;&amp; this.active.youtubeId === videoId) {
			client.emit('be_alerted', 'This song is currently playing.');

			return;
		}

		// check if song already exists in queue, prevent adding
		for(let queueItem of this.getItems()) {
			if(queueItem.youtubeId === videoId) {
				client.emit('be_alerted', 'This song is already in the queue. Try voting for it instead.');

				return;
			}
		}

		youTubeApi.getVideo(videoId).then(data => {
			if(data.pageInfo.totalResults > 0) {
				if( ! data.items[0].status.embeddable) {
					this.emitToAll('be_alerted', `Sorry, the video with ID: ${videoId} is not embeddable. Try adding a different one.`);
					return;
				}

				let title = data.items[0].snippet.title;
				let resultDuration = data.items[0].contentDetails.duration;
				let durationInMs = moment.duration(resultDuration).asMilliseconds();

				this.items.push(new Song(videoId, title, durationInMs, client));

				this.triggerOnQueueChanged();
			}
		}).catch(error => {
            Logger.error('Queue-add error', error);
		});
	}

	/**
	 * Removes an item from the queue by videoId.
	 * Should only work when the client provided
	 * is the client who added the song initially
	 *
	 * Note: Triggers {@link this.triggerOnQueueChanged} when song is removed
	 *
	 * @param {Client} client
	 * @param {String} videoId
	 */
	deleteItem(client, videoId) {
		let song = this.items.filter((item) => {
			return item.id === videoId;
		});
		if (! song.length) {
			return;
		}

		song = song[0];
		if (song.addedBy.id === client.id) {
			let index = this.items.indexOf(song);
			this.items.splice(index, 1);

			this.triggerOnQueueChanged();
		}
	}

	/**
	 * This is the main queue loop, it
	 * checks if the current song is
	 * over to start the next one.
	 *
	 * Note: It will emit `song_info` event to all users on each run
	 * Note: It will send `new_song` event to all users when a song starts
	 */
	work() {
		if(this.active === null || this.active.isOver()) {
			// When nothing is in the queue
			if(this.items.length === 0) {
				if(this.relatedVideoIsLoading) {
					// Wait for the related video to load
					return;
				}

				// Add the first related video to queue (asynchronous!)
				if(this.active !== null &amp;&amp; this.active.relatedVideos.length) {
					this.add({}, this.active.relatedVideos[0].youtubeId);
					this.relatedVideoIsLoading = true;
				}

				// Nothing active or no related videos found
				return;
			}
			// Reset the value of the flag, used when loading related videos on empty queue
			this.relatedVideoIsLoading = false;

			// The next song would be the first one from the sorted queue
			let newSong = this.getItems().shift();

			// Remove the song we just took - from the original items array
			let newSongIndexInQueue = this.items.indexOf(newSong);
			this.items.splice(newSongIndexInQueue, 1);

			this.triggerOnQueueChanged();

			newSong.play();

			this.active = newSong;

			// Load related videos for newly played active song
			this.active.loadRelatedVideos(() => {
				this.triggerOnRelatedChanged(this.active);
			});

			// Emit to all users:
			let info = {
				url_params: this.active.getVideoUrlParams(),
				info: this.active.getInfo()
			};

			this.emitToAll('new_song', info);
		}

		// Send current song info:
		let newSongInfo = this.active.getInfo();
		this.emitToAll('song_info', newSongInfo);
	}

	/**
	 * Schedules {@link this.work} to run
	 * every second so it will check the
	 * queue items and do it's magic
	 */
	run() {
		this.queueInterval = setInterval(() => {
			this.work();
		}, 1000);
	}

	/**
	 * Stops the scheduled {@link this.work},
	 * which was started with {@link this.run}
	 */
	stop() {
		clearInterval(this.queueInterval);
	}
}

module.exports = Queue;</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue May 02 2017 21:52:36 GMT+0300 (FLE Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
